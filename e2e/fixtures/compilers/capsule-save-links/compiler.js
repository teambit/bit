/**
 * compiler that supports the capsule interface.
 * remove the string stringToRemovedByCompiler so then the dists will be valid to run
 */
const path = require('path');
const os = require('os');

const stringToRemovedByCompiler = 'export const A = "THIS STRING SHOULD BE REMOVED BY THE DUMMY COMPILER";\n';

function compile(files, distPath, context) {
  const targetDir = path.join(os.tmpdir(), generateRandomStr());
  const distSignature = '// THIS IS A DIST FILE GENERATED BY A DUMMY COMPILER\n';
  return context.isolate({ targetDir, shouldBuildDependencies: true })
    .then((isolateResults) => {
      const { componentWithDependencies } = isolateResults;
      const componentRootDir = path.join(targetDir, componentWithDependencies.component.writtenPath);
      const distFiles = files
        .map((file) => {
          const distFile = file.clone();
          const content = distSignature + file.contents.toString().replace(stringToRemovedByCompiler, '');
          distFile.base = distPath;
          distFile.path = path.join(distPath, file.relative);
          distFile.contents = Buffer.from(content);
          return distFile;
        })
      return { distFiles, isolateResults };
    })
    .then(({ distFiles, isolateResults }) => {
      return isolateResults.writeDists(distFiles).then(() => ({ distFiles, isolateResults }));
    })
    .then(({ distFiles, isolateResults }) => {
      const linkFiles = isolateResults.getDependenciesLinks();
      const componentSrcLinkFiles = linkFiles.filter(f => f.path.startsWith('dist'));
      componentSrcLinkFiles.forEach((linkFile) => {
        linkFile.base = distPath;
        linkFile.path = path.join(distPath, linkFile.relative);
        distFiles.push(linkFile);
      });
      return distFiles;
    })
}

function generateRandomStr(size = 8) {
  return Math.random()
    .toString(36)
    .slice(size * -1);
}

module.exports = {
  compile,
  stringToRemovedByCompiler
};
