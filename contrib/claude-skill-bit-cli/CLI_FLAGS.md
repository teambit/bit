# Bit CLI Command Reference

## bit add [path...]

track existing directory contents as new components in the workspace

Registers one or more directories as Bit components without changing your files. Each provided path becomes a component root tracked by Bit.
Flags: --id <name>, --main <file>, --namespace <namespace>, --override <boolean>, --scope <string>, --env <string>, --json

## bit app [sub-command]

manage application components

applications are components that create deployable, runnable applications like React apps or Node.js servers. list available apps in the workspace and inspect their configurations. use "bit run" to start an application locally.

## bit app list

list all registered apps
Flags: --json

## bit app run [app-name]

start an application component locally

runs application components in their own development server, separate from the "bit start" UI. apps are components that create deployable applications (React apps, Node.js servers, etc.). when no app name is specified, automatically detects and runs the app if only one exists in the workspace.
Flags: --dev, --port [port-number], --verbose, --watch, --no-browser, --args <argv>

## bit artifacts <component-pattern>

view and download build artifacts

displays artifacts created during the build pipeline in isolated capsules during tag or snap operations. artifacts include compiled files, test reports, package files, and other build outputs generated by various tasks. use --out-dir to download artifacts locally for inspection or deployment purposes.
Flags: --aspect <aspect-id>, --task <task-id>, --files <glob>, --out-dir <string>

## bit aspect <sub-command>

manage component aspects and their configurations

aspects provide functionality and tools for components throughout their development lifecycle. primarily useful for inspecting aspect assignments and configurations with "bit aspect get". rarely used for manual aspect management as most aspects are configured automatically.

## bit aspect list [pattern]

list all aspects configured on component(s)
Flags: --debug

## bit aspect list-core <pattern>

list all core aspects
Flags: --json

## bit aspect get <component-name>

list the aspects set on a component, as well as their configs and data
Flags: --debug, --json

## bit aspect set <pattern> <aspect-id> [config]

set components with an aspect to extend their development tools, metadata and (possibly) artifacts
Flags: --merge

## bit aspect unset <pattern> <aspect-id>

unset an aspect from component(s).

## bit aspect update <aspect-id> [pattern]

update a version of an aspect for all or specified components

## bit blame <filepath>

EXPERIMENTAL. show line-by-line authorship and modification history

displays who last modified each line of a file and when the change was made. tracks line-level changes across component versions. shows author, date, version hash, and optionally commit messages for each line.
Flags: --include-message

## bit build [component-pattern]

run build pipeline tasks in isolated environments

executes the complete build pipeline including compilation, testing, linting, and other tasks defined by component environments. the build takes place in isolated directories called "capsules" where component files are copied and dependencies are installed via the package manager. by default processes only new and modified components - use --unmodified to build all components. because this process can take a while on large workspaces, various flags are available to optimize the process - see examples for debugging workflows.
Flags: --unmodified, --dev, --install, --reuse-capsules, --rewrite, --reinstall, --tasks <string>, --cache-packages-on-capsule-root, --list-tasks <string>, --skip-tests, --loose, --skip-tasks <string>, --fail-fast, --include-snap, --include-tag, --ignore-issues <issues>

## bit capsule

manage isolated component environments

capsules are temporary isolated directories containing component code and dependencies. automatically created during build processes to compile and test components in isolation. ensures components work independently before publishing, similar to how they'll be consumed.
Flags: --json

## bit capsule list

list the capsules generated for this workspace
Flags: --json

## bit capsule create [component-id...]

create capsules for components
Flags: --base-dir <name>, --root-base-dir <name>, --always-new, --seeders-only, --id <name>, --use-hash, --json, --install-packages, --package-manager <name>

## bit capsule delete

delete capsules

with no args, only workspace's capsules are deleted
Flags: --scope-aspects, --all

## bit check-types [component-pattern]

validate TypeScript type correctness

checks for TypeScript type errors in component files, similar to running tsc. by default only checks new and modified components. use --unmodified to check all components. useful for catching type issues before tagging, snapping or building components.
Flags: --unmodified, --strict, --json

## bit checkout <to> [component-pattern]

switch between component versions or remove local changes

checkout components to specified versions or remove local changes. most commonly used as 'bit checkout head' to get latest versions. the `<to>` argument accepts these values: - head: checkout to last snap/tag (most common usage) - specific version: checkout to exact version (e.g. 'bit checkout 1.0.5 component-name') - head~x: go back x generations from head (e.g. 'head~2' for two versions back) - latest: checkout to latest semver tag - reset: remove local modifications and restore original files (also restores deleted component directories) when on lanes, 'checkout head' only affects lane components. to update main components, run 'bit lane merge main'.
Flags: --interactive-merge, --auto-merge-resolve <merge-strategy>, --manual, --all, --workspace-only, --verbose, --skip-dependency-installation, --force-ours, --force-theirs

## bit ci <sub-command>

continuous integration commands for automated workflows

provides commands designed for use in CI/CD pipelines with Git workflows to automate component development tasks like verification, pull request handling, and deployment preparation.

## bit ci verify

Ensures the workspace passes CI checks on every commit.

Runs lint, build, and status checks to catch dependency drift or broken builds early. Typically used as a pre-push hook or early CI job. Stops at the first failing step and returns a non-zero exit code.

## bit ci pr

Exports a feature lane to Bit Cloud when a Pull Request is opened or updated.

Resolves the lane name from --lane or the current Git branch, validates it, and runs install, status, snap, and export. Cleans up by switching back to main. Use in pull-request CI pipelines after tests and before deploy.
Flags: --message <message>, --lane <lane>, --build, --strict

## bit ci merge

Tags and exports new semantic versions after merging a PR to main.

By default, bumps patch versions when merging to main. If specific configuration variables are set, it can use commit messages or explicit flags to determine the version bump. Runs install, tag, build, and export, then archives the remote lane and syncs lockfiles. Use in merge-to-main CI pipelines to publish releases.
Flags: --message <message>, --build, --strict, --increment <level>, --prerelease-id <id>, --patch, --minor, --major, --pre-release [identifier], --increment-by <number>, --versions-file <path>, --verbose, --auto-merge-resolve <merge-strategy>, --force-theirs, --lane-name <name>

## bit clear-cache

remove cached data to resolve stale data issues

clears various caches that Bit uses to improve performance. useful when experiencing stale data issues or unexpected behavior. this command removes: 1) components cache on the filesystem (mainly the dependencies graph and docs) 2) scope's index file, which maps the component-id:object-hash note: this cache has minimal impact on disk space. to free significant disk space, use "bit capsule delete --all" to remove build capsules.
Flags: --remote <remote-name>

## bit compile [component-names...]

transpile component source files

compiles TypeScript, JSX, and other source files into JavaScript using the compiler configured by each component's environment. outputs compiled files to node_modules/component-package-name/dist for consumption by other components. automatically triggered by "bit watch", "bit start", or IDE extensions, but can be run manually for debugging.
Flags: --changed, --verbose, --json, --delete-dist-dir, --generate-types

## bit config

manage Bit configuration settings

view and modify Bit configuration at different levels: global, workspace, or scope. configurations control various aspects of Bit including user settings, registries, and feature flags. use environment variables prefixed with BIT*CONFIG* for temporary overrides. https://bit.dev/reference/config/bit-config

## bit config set <key> <val>

set a configuration. default to save it globally

to set temporary configuration by env variable, prefix with "BIT*CONFIG", replace "." with "*" and change to upper case. for example, "user.token" becomes "BIT_CONFIG_USER_TOKEN"
Flags: --local, --local-track

## bit config del <key>

delete given key from global configuration
Flags: --origin <origin>

## bit config get <key>

get a value from global configuration

## bit config list

list all configuration(s)
Flags: --origin <origin>, --detailed, --json

## bit create <template-name> <component-names...>

scaffold new component(s) from a template (sources, config, and env)

Generates one or more components from a chosen template with ready-to-use source files, configuration, and environment. Use it to quickly scaffold consistent components across your workspace. Run 'bit templates' to discover available templates.
Flags: --namespace <string>, --scope <string>, --aspect <string>, --template <string>, --path <string>, --env <string>, --force

## bit delete <component-pattern>

soft-delete components from remote scopes

marks components as deleted so they won't be visible on remote scopes after export. components remain recoverable using "bit recover" unless --hard is used (permanent deletion, not recommended). to remove components from your local workspace only, use "bit remove" instead.
Flags: --lane, --update-main, --range <string>, --silent, --hard, --force, --snaps <string>

## bit dependents <component-name>

show components that depend on the specified component

displays components from both workspace and scope that depend on the specified component. useful for understanding impact before making changes to a component or when planning refactoring. shows both direct and transitive dependents organized by their origin (workspace vs scope).
Flags: --json

## bit deprecate <component-name>

mark a component as deprecated to discourage its use

marks a component as deprecated locally, then after snap/tag and export it becomes deprecated in the remote scope. optionally specify a replacement component or deprecate only specific version ranges. deprecated components remain available but display warnings when installed or imported.
Flags: --new-id <string>, --range <string>

## bit deps <sub-command>

manage component dependencies

configure and analyze component dependencies with sub-commands for setting, removing, and inspecting dependency relationships.

## bit deps get <component-name>

show direct and indirect dependencies of the given component
Flags: --scope, --tree

## bit deps remove <component-pattern> <package...>

remove a dependency from one or more components

this command removes the dependency whether it was set by 'bit deps set'/variants or by auto-detection. if the dependency was auto-detected, it will be marked with a minus sign in the .bitmap file. otherwise, the config is written to .bitmap without the dependency. see also 'bit deps unset'
Flags: --dev, --peer

## bit deps unset <component-pattern> <package...>

unset a dependency to component(s) that was set via config (e.g. "bit deps set" or variants)

this command removes the dependency only when it was set by config not if it was auto detected. in the .bitmap file, the config is written without the dependency. see also "bit deps remove"
Flags: --dev, --peer

## bit deps debug <component-name>

show the immediate dependencies and how their versions were determined

## bit deps set <component-pattern> <package...>

set a dependency to component(s)
Flags: --dev, --optional, --peer

## bit deps reset <component-pattern>

reset dependencies to the default values (revert any previously "bit deps set")

## bit deps eject <component-pattern>

write dependencies that were previously set via "bit deps set" into .bitmap

## bit deps blame <component-name> <dependency-name>

find out which snap/tag changed a dependency version

## bit deps usage <dependency-name>

find components that use the specified dependency

searches workspace components to find which ones depend on the specified package or component. useful for understanding dependency usage before removing packages or when refactoring components. supports both exact version matching and package name patterns.
Flags: --depth <number>

## bit deps write

write all workspace component dependencies to package.json or workspace.jsonc, resolving conflicts by picking the ranges that match the highest versions
Flags: --target <workspace.jsonc|package.json>

## bit diff [component-pattern] [version] [to-version]

compare component changes between versions or against the current workspace

shows a detailed diff of component files, dependencies, and configuration changes. by default, compares workspace changes against the latest version. specify versions to compare historical changes. supports pattern matching to filter components and various output formats for better readability.
Flags: --parent, --verbose, --table

## bit doctor [diagnosis-name]

diagnose and troubleshoot workspace issues

runs comprehensive health checks on your workspace to detect and report configuration problems, missing dependencies, corrupted data, and other issues that may affect workspace functionality. can generate diagnostic reports and workspace archives for debugging and support purposes.
Flags: --json, --list, --save [filePath], --archive [filePath], --include-node-modules, --include-public, --exclude-local-scope, --remote <remoteName>

## bit eject <component-pattern>

remove component from workspace and install it as npm package

converts workspace components to external npm packages by removing them from .bitmap and installing via package manager. by default removes component files from workspace. use --keep-files to preserve source code while converting to package dependency. useful for components that no longer need active development in current workspace.
Flags: --force, --skip-dependency-installation, --json, --keep-files

## bit eject-conf <pattern>

create component.json configuration files for components

generates component.json files containing component-specific configuration that overrides workspace defaults. useful for customizing individual component settings. alternatively, use commands like "bit env set", "bit deps set", or "bit aspect set". can be reversed by deleting the component.json file and snapping/tagging the changes. you can use a `<pattern>` for multiple component ids, such as `bit eject-conf "org.scope/utils/**"`. use comma to separate patterns and '!' to exclude. e.g. 'ui/\*\*, !ui/button' use '$' prefix to filter by states/attributes, e.g. '$deprecated', '$modified' or '$env:teambit.react/react'. always wrap the pattern with single quotes to avoid collision with shell commands. use `bit pattern --help` to understand patterns better and `bit pattern <pattern>` to validate the pattern.
Flags: --propagate, --override

## bit envs

show components and their assigned environments

displays a table showing each workspace component and its corresponding environment. environments control how components are built, tested, linted, and deployed.

## bit envs list

list all envs currently used in the workspace

## bit envs get <component-name>

show config information from a component's env
Flags: --services <string>

## bit envs set <component-pattern> <env>

Assigns one or more components a development environment (env)

## bit envs unset <component-pattern>

un-sets an env from components that were previously set by "bit env set" or by a component template

keep in mind that this doesn't remove envs that are set via variants. in only removes envs that appear in the .bitmap file, which were previously configured via "bit env set". the purpose of this command is to reset previously assigned envs to either allow variants configure the env or use the base node env. you can use a `<pattern>` for multiple component ids, such as `bit env unset "org.scope/utils/**"`. use comma to separate patterns and '!' to exclude. e.g. 'ui/\*\*, !ui/button' use '$' prefix to filter by states/attributes, e.g. '$deprecated', '$modified' or '$env:teambit.react/react'. always wrap the pattern with single quotes to avoid collision with shell commands. use `bit pattern --help` to understand patterns better and `bit pattern <pattern>` to validate the pattern.

## bit envs replace <current-env> <new-env>

replace an existing env with another env for all components using the old env

## bit envs update [env-id] [pattern]

update a version of an env for all components using that env

## bit export [component-patterns...]

upload components to remote scopes

uploads staged versions (snaps/tags) to remote scopes, making them available for consumption by other workspaces. without arguments, exports all staged components. when on a lane, exports the lane as well. exporting is the final step after development and versioning to share components with your team.
Flags: --eject, --all, --all-versions, --origin-directly, --resume <string>, --head-only, --ignore-missing-artifacts, --fork-lane-new-scope, --open-browser, --verbose, --json

## bit fork <pattern> [target-component-name]

create a new component by copying from an existing one

duplicates an existing component's source files and configuration to create a new independent component. useful for creating variations or starting development from a similar component. automatically handles import/require statement updates and provides refactoring options. when using a pattern, all matching components are forked with the same name to a target scope. the target-component-name argument is not allowed when using patterns.
Flags: --scope <string>, --path <string>, --refactor, --skip-dependency-installation, --env <string>, --skip-config, --preserve, --no-link, --ast

## bit format [component-pattern]

auto-format component source code

formats component files using the formatter configured by each component's environment (Prettier, etc.). by default formats all components. use --changed to format only new and modified components. supports check mode to verify formatting without making changes.
Flags: --changed, --check, --json

## bit git <sub-command>

Git utilities for Bit repositories

provides specialized Git utilities for handling Bit-specific files and conflicts. includes tools for setting up merge drivers for bitmap files and resolving conflicts during Git merges. essential for properly handling Bit's internal files when working with Git repositories.

## bit git set-merge-driver

setup bit's git merge driver for bitmap files
Flags: --global

## bit globals

display global directories and paths used by Bit

shows all global directories including cache, logs, and config locations used by Bit across your system. useful for debugging and understanding where Bit stores data.
Flags: --json

## bit graph [id]

visualize component dependencies as a graph image

generates an SVG (or PNG) image showing component dependency relationships. black arrows represent runtime dependencies, red arrows show dev or peer dependencies. by default shows only workspace components; use --include-dependencies for full dependency tree.
Flags: --remote [remoteName], --layout <name>, --png, --cycles, --include-dependencies, --json

## bit help

display available commands and usage information

shows a categorized list of all available Bit commands with brief descriptions. use `bit <command> --help` for detailed help on specific commands.
Flags: --internal

## bit import [component-patterns...]

bring components from remote scopes into your workspace

brings component source files from remote scopes into your workspace and installs their dependencies as packages. supports pattern matching for bulk imports, merge strategies for handling conflicts, and various optimization options. without arguments, fetches all workspace components' latest versions from their remote scopes.
Flags: --path <path>, --objects, --override, --verbose, --json, --skip-dependency-installation, --skip-write-config-files, --merge [strategy], --dependencies, --dependencies-head, --dependents, --dependents-via <string>, --dependents-all, --silent, --filter-envs <envs>, --save-in-lane, --all-history, --fetch-deps, --write-deps <workspace.jsonc|package.json>, --track-only, --include-deprecated, --lane-only, --owner

## bit init [path]

initialize a Bit workspace in an existing project

creates Bit configuration files in an existing project directory to start tracking components. if already a workspace, validates and repairs Bit files as needed. supports various reset options to recover from corrupted state or restart from scratch.
Flags: --name <workspace-name>, --generator <env-id>, --standalone, --no-package-json, --reset, --reset-new, --reset-lane-new, --reset-hard, --reset-scope, --default-directory <default-directory>, --default-scope <default-scope>, --force, --bare [name], --shared <groupname>, --external-package-manager, --skip-interactive

## bit install [packages...]

install workspace dependencies

installs workspace dependencies and prepares the workspace for development. when packages are specified, adds them to workspace.jsonc policy and installs. when no packages specified, installs existing dependencies. automatically imports components, compiles components, links to node_modules, and writes config files.
Flags: --type [lifecycleType], --update, --save-prefix [savePrefix], --skip-dedupe, --skip-import, --skip-compile, --skip-write-config-files, --add-missing-deps, --skip-unavailable, --add-missing-peers, --recurring-install, --no-optional [noOptional], --lockfile-only, --allow-scripts [pkgNames], --disallow-scripts [pkgNames]

## bit lane [sub-command]

manage lanes for parallel development

lanes allow isolated development of features without affecting main branch components. create, switch between, and merge lanes to coordinate parallel work across teams. without a sub-command, lists all available lanes.
Flags: --details, --json, --remote <remote-scope-name>, --merged, --not-merged

## bit lane list

list local or remote lanes
Flags: --details, --json, --remote <remote-scope-name>, --merged, --not-merged

## bit lane show [lane-name]

show lane details. if no lane specified, show the current lane
Flags: --json, --remote

## bit lane create <lane-name>

creates a new lane and switches to it

a lane created from main (default-lane) is empty until components are snapped. a lane created from another lane contains all the components of the original lane.
Flags: --scope <scope-name>, --alias <name>, --fork-lane-new-scope

## bit lane remove <lanes...>

remove or delete lanes
Flags: --remote, --force, --silent

## bit lane change-scope <remote-scope-name>

changes the remote scope of a lane

NOTE: available only before the lane is exported to the remote
Flags: --lane-name <lane-name>

## bit lane alias <lane-name> <alias>

adds an alias to a lane

an alias is a name that can be used locally to refer to a lane. it is saved locally and never reaches the remote. it is useful e.g. when having multiple lanes with the same name, but with different remote scopes.

## bit lane rename <new-name>

change the lane-name locally

the remote will be updated after the next "bit export" command
Flags: --lane-name <lane-name>

## bit lane remove-readme [laneName]

DEPRECATED (only use it if you have used add-readme and want to undo it). remove lane readme component

## bit lane import <lane>

import a remote lane to your workspace and switch to that lane
Flags: --skip-dependency-installation, --pattern <component-pattern>, --branch

## bit lane remove-comp <component-pattern>

DEPRECATED. remove components when on a lane
Flags: --workspace-only, --update-main

## bit lane fetch [lane-id]

fetch component objects from lanes. if no lane-id is provided, it fetches from the current lane

note, it does not save the remote lanes objects locally, only the refs
Flags: --all

## bit lane eject <component-pattern>

delete a component from the lane and install it as a package from main

NOTE: unlike "bit eject" on main, this command doesn't only remove the component from the workspace, but also mark it as deleted from the lane, so it won't be merged later on.

## bit lane history [lane-name]

EXPERIMENTAL. show lane history, default to the current lane

list from the oldest to the newest history items
Flags: --id <string>, --json

## bit lane history-diff <from-history-id> <to-history-id>

EXPERIMENTAL. show diff between two lane-history ids

run "bit lane history" to find these history-ids
Flags: --lane <lane-name>, --pattern <component-pattern>

## bit lane checkout <history-id>

EXPERIMENTAL. checkout to a previous history of the current lane. see also "bit lane revert"
Flags: --skip-dependency-installation

## bit lane revert <history-id>

EXPERIMENTAL. revert to a previous history of the current lane. see also "bit lane checkout"

revert is similar to "lane checkout", but it keeps the versions and only change the files. choose one or the other based on your needs. if you want to continue working on this lane and needs the changes from the history to be the head, then use "lane revert". if you want to fork the lane from a certain point in history, use "lane checkout" and create a new lane from it.
Flags: --skip-dependency-installation, --restore-deleted-components, --json

## bit lane merge-move <new-lane-name>

EXPERIMENT. move the current merge state into a new lane. the current lane will be reset

this command is useful when you got a messy merge state that from one hand you don't want to loose the changes, but on the other hand, you want to keep your lane without those changes. this command does the following: 1. create a new lane with the current merge state. including all the filesystem changes. (in practice, it leaves the fs intact) 2. reset the current lane to the state before the merge. so then once done with the new lane, you can switch to the current lane and it'll be clean.
Flags: --scope <scope-name>

## bit link [component-names...]

create links between components and node_modules

creates links in node_modules for workspace components and core aspects, enabling import resolution. automatically links all workspace components and Bit's core aspects to their respective package names. useful for development when components need to reference each other or when debugging linking issues.
Flags: --json, --verbose, --rewire, --target <dir>, --skip-fetching-objects, --peers, --comp-summary

## bit lint [component-pattern]

analyze component code for issues and style violations

runs linters configured by each component's environment (ESLint, etc.) to check for code quality issues. by default lints all components. use --changed to lint only new and modified components. supports automatic fixing of certain issues with --fix flag.
Flags: --changed, --fix, --fix-type <fixType>, --json

## bit list [remote-scope]

display components in workspace or remote scope

shows components in the current workspace by default, or from a specified remote scope. supports filtering by scope, namespace, and various display options. use --outdated to highlight components that have newer versions available.
Flags: --ids, --local-scope, --scope <string>, --outdated, --include-deleted, --json, --namespace <string>

## bit local-only <sub-command>

manage components that exist only in the workspace

controls components that are excluded from versioning (snap/tag) and exporting operations. local-only components are useful for workspace-specific tools, configs, or temporary components. these components remain in the workspace but won't be shared or versioned.

## bit local-only set <component-pattern>

set a component as local-only

## bit local-only unset <component-pattern>

remove a component from local-only

## bit local-only list

list all local-only components

## bit log <id>

display component version history

shows chronological history of component versions including tags and snaps with metadata. displays commit messages, authors, dates, and version information. supports both local and remote component logs. use various format options for compact or detailed views of version history.
Flags: --remote, --parents, --one-line, --full-hash, --full-message, --show-hidden, --json

## bit log-file <filepath>

EXPERIMENTAL. display history of changes to a specific file

shows version history for a specific file within component versions. tracks file-level changes across component snaps and tags. displays file modifications, hashes, and associated commit information.
Flags: --one-line

## bit login

authenticate with Bit Cloud for component publishing and collaboration

opens browser to authenticate with Bit Cloud (bit.cloud) and obtain access token for publishing components. automatically updates .npmrc file with registry configuration and authentication token for seamless package publishing. supports custom cloud domains, CI/machine authentication, and manual token refresh options.
Flags: --skip-config-update, --refresh-token, --cloud-domain <domain>, --default-cloud-domain, --port <port>, --no-browser, --machine-name <name>, --suppress-browser-launch

## bit logout

sign out of Bit Cloud and clear authentication tokens

removes stored authentication tokens and signs out of Bit Cloud. clears local credentials while preserving .npmrc configurations. use this to switch between accounts or when authentication tokens expire.

## bit mcp-server [sub-command]

start Model Context Protocol server for AI assistants

enables AI assistants and other tools to interact with Bit via the Model Context Protocol. provides a standardized interface for AI agents to execute Bit commands and access component information. allows writing custom instructions and rules to guide AI agents in their interactions with Bit.
Flags: --include-additional <commands>, --bit-bin <binary>, --consumer-project

## bit mcp-server start

Start the MCP server

Start the Model Context Protocol (MCP) server with the specified configuration
Flags: --include-additional <commands>, --bit-bin <binary>, --consumer-project

## bit mcp-server setup [editor]

Setup MCP integration with VS Code, Cursor, Windsurf, Roo Code, Cline, Claude Code, or other editors

Creates or updates configuration files to integrate Bit MCP server with supported editors. Currently supports VS Code, Cursor, Windsurf, Roo Code, Cline, and Claude Code.
Flags: --consumer-project, --include-additional <commands>, --global

## bit mcp-server rules [editor]

Write Bit MCP rules/instructions file for VS Code, Cursor, Roo Code, Cline, Claude Code, or print to screen

Creates or updates rules/instructions markdown files to provide AI assistants with guidance on using Bit MCP server. Currently supports VS Code, Cursor, Roo Code, Cline, and Claude Code. For Claude Code, creates .claude/bit.md to avoid overwriting existing CLAUDE.md files. Use --print to display content on screen. Use --consumer-project for non-Bit workspaces that only consume components as packages. Use --force-standard to use standard Bit rules instead of Git-integrated template.
Flags: --global, --print, --consumer-project, --force-standard

## bit merge [component-pattern]

merge diverged component history when local and remote have different versions

resolves diverged component history when both local and remote have created different snaps/tags from the same base version. if no component pattern is specified, all pending-merge components will be merged (run 'bit status' to list them). 'bit status' will show diverged components and suggest either merging or resetting local changes. preferred approach: use 'bit reset' to remove local versions, then 'bit checkout head' to get remote versions. for lane-to-lane merging, use 'bit lane merge' instead.
Flags: --manual, --auto-merge-resolve <merge-strategy>, --abort, --resolve, --no-snap, --build, --verbose, --skip-dependency-installation, --message <message>

## bit move <current-component-dir> <new-component-dir>

relocate a component to a different directory

moves component files to a new location within the workspace and updates the .bitmap tracking. only changes the filesystem location - does not affect the component's name, scope, or ID. useful for reorganizing workspace structure or following new directory conventions.

## bit new <template-name> <workspace-name>

create a new Bit workspace from a template

initializes a new Bit workspace with pre-configured settings, environments, and optionally starter components. templates provide different setups for React, Angular, Node.js, or custom development workflows. installs dependencies and configures the workspace for immediate development.
Flags: --aspect <aspect-id>, --template <env-id>, --env <env-id>, --default-scope <scope-name>, --skip-git, --empty, --load-from <path-to-template>, --current-dir

## bit npmrc [sub-command]

configure .npmrc file with Bit Cloud registry and authentication settings

manages .npmrc configuration for seamless package installation from Bit Cloud registries. automatically configures scoped registries and authentication tokens for your workspace components. provides sub-commands for generating, updating, and managing npm registry configurations.

## bit npmrc generate

update npmrc file with scope, registry, and token information from bit.cloud
Flags: --dry-run, --force

## bit pattern <pattern>

test and validate component patterns

this command helps validating a pattern before using it in other commands. NOTE: always wrap the pattern with quotes to avoid collision with shell commands. depending on your shell, it might be single or double quotes. a pattern can be a simple component-id or component-name. e.g. 'ui/button'. a pattern can be used with wildcards for multiple component ids, e.g. 'org.scope/utils/**' or '**/utils/**' to capture all org/scopes. to enter multiple patterns, separate them by a comma, e.g. 'ui/_, lib/_' to exclude, use '!'. e.g. 'ui/**, !ui/button' the matching algorithm is from multimatch (@see https://github.com/sindresorhus/multimatch). to filter by a state or attribute, prefix the pattern with "$". e.g. '$deprecated', '$modified'. list of supported states: [new, modified, deprecated, deleted, snappedOnMain, softTagged, codeModified, localOnly]. to filter by multi-params state/attribute, separate the params with ":", e.g. '$env:teambit.react/react'. list of supported multi-params states: [env]. to match a state and another criteria, use " AND " keyword. e.g. '$modified AND teambit.workspace/\*\* AND $env:teambit.react/react'.
Flags: --json, --remote

## bit recover <component-pattern>

restore soft-deleted components

reverses the soft-deletion of components marked with "bit delete", restoring them to their previous state. works for both local and remote soft-deleted components. supports patterns like "comp1", "org.scope/\*", etc.
Flags: --skip-dependency-installation, --skip-write-config-files

## bit refactor <sub-command>

automatically refactor component source code

performs automated code transformations and refactoring operations across components. currently supports updating import/require statements when component names or dependencies change. useful for maintaining code consistency after renaming or restructuring components.

## bit refactor dependency-name <old-id> <new-id>

replace the dependency's old package-name with a new one in the code

the `<old-id>` and `<new-id>` arguments can be either a component-id or a package-name.

## bit remote

manage remote scopes for self-hosted environments

configure connections to self-hosted remote scopes via HTTP or file protocol. note: this command is only needed for self-hosted scopes. when using bit.cloud, remote scopes are automatically configured. remotes are bare scopes that store exported components and enable collaboration across teams.
Flags: --global

## bit remote add <url>

add a bare-scope as a remote

supported protocols are [file, http]. for example: "http://localhost:3000", "file:///tmp/local-scope"
Flags: --global

## bit remote del <name>

remove a tracked bit remote
Flags: --global

## bit remote list

list all configured remotes
Flags: --global

## bit remove <component-pattern>

untrack components from the workspace

removes components from the local workspace only - stops tracking them in .bitmap and deletes their files by default. does not affect remote scopes - to delete components from remotes, use "bit delete" instead. use --keep-files to preserve component files while only removing the tracking.
Flags: --track, --keep-files, --force, --silent

## bit rename <current-name> <new-name>

change a component name

renames a component and optionally refactors dependent code to use the new name. for exported components: creates a new component with the new name and marks the original as deleted. for local components: simply renames the existing component in place.
Flags: --scope <scope-name>, --refactor, --preserve, --ast, --deprecate, --path <relative-path>

## bit reset [component-pattern]

revert local tags and snaps to previous versions

removes local component versions (tags/snaps) that haven't been exported yet. if no component-pattern is provided, resets all components (with confirmation prompt). by default reverts all local versions of each component. use --head to revert only the latest version. useful for undoing mistakes before exporting. exported versions cannot be reset.
Flags: --head, --soft, --force, --never-exported, --silent

## bit revert <component-pattern> <to>

replace component files with specified version while preserving current version

replaces component source files with files from the specified version but keeps the current component version. useful for reverting file changes without changing the component's version history. different from checkout which changes the version.
Flags: --verbose, --skip-dependency-installation

## bit run [app-name]

start an application component locally

runs application components in their own development server, separate from the "bit start" UI. apps are components that create deployable applications (React apps, Node.js servers, etc.). when no app name is specified, automatically detects and runs the app if only one exists in the workspace.
Flags: --dev, --port [port-number], --verbose, --watch, --no-browser, --args <argv>

## bit schema <pattern>

display component API schema and type definitions

extracts and displays the public API structure of components including types, functions, classes, and interfaces. shows detailed type information, function signatures, and JSDoc documentation for exported elements. useful for understanding component interfaces and generating documentation. you can use a `<pattern>` for multiple component ids, such as `bit schema "org.scope/utils/**"`. use comma to separate patterns and '!' to exclude. e.g. 'ui/\*\*, !ui/button' use '$' prefix to filter by states/attributes, e.g. '$deprecated', '$modified' or '$env:teambit.react/react'. always wrap the pattern with single quotes to avoid collision with shell commands. use `bit pattern --help` to understand patterns better and `bit pattern <pattern>` to validate the pattern.
Flags: --remote, --json

## bit scope <sub-command>

manage component scope names and assignments

configure scope assignments for components including setting default scopes and renaming existing scopes. scopes determine where components are stored and published, forming the first part of component IDs. essential for organizing components and managing component namespaces across teams.

## bit scope set <scope-name> [component-pattern]

Sets the scope for specified component/s. If no component is specified, sets the default scope of the workspace

default scopes for components are set in the bitmap file. the default scope for a workspace is set in the workspace.jsonc. a component is set with a scope (as oppose to default scope) only once it is versioned.' you can use a `<pattern>` for multiple component ids, such as `bit scope set scope-name "org.scope/utils/**"`. use comma to separate patterns and '!' to exclude. e.g. 'ui/\*\*, !ui/button' use '$' prefix to filter by states/attributes, e.g. '$deprecated', '$modified' or '$env:teambit.react/react'. always wrap the pattern with single quotes to avoid collision with shell commands. use `bit pattern --help` to understand patterns better and `bit pattern <pattern>` to validate the pattern.

## bit scope rename <current-scope-name> <new-scope-name>

rename the scope name for all components with the specified 'current scope name'. if exported, create new components and delete the original ones

Note: if `<current-scope-name>` is also the defaultScope for the workspace, this command will set `<new-scope-name>` as the defaultScope instead, and that will then be set for all components by default. You may see updates in your .bitmap file as a result of this change
Flags: --preserve, --refactor, --deprecate

## bit scope rename-owner <current-owner-name> <new-owner-name>

Renames the owner part of the scope-name for all components with the specified 'current owner name'
Flags: --refactor, --ast

## bit scope fork <original-scope> [new-scope] [pattern]

fork all components of the original-scope and refactor the source-code to use the new scope name

optionally, provide [pattern] to limit the fork to specific components
Flags: --ast, --skip-dependency-installation

## bit script [script-name]

run a script defined by the environment

executes custom scripts defined by component environments. scripts can be shell commands or JavaScript functions defined in env.scripts(). runs the script for all components grouped by their environment. use --list to see all available scripts.
Flags: --list

## bit set-peer <component-id> <range>

configure component to always be installed as peer dependency

marks a component to always be treated as a peer dependency when used by other components. useful for shared libraries that should be provided by the consuming application. the specified version range will be used when adding this component as a peer dependency.

## bit show <component-name>

display component metadata, dependencies, and configuration

shows detailed information about a component including its version, dependencies, environment, and other metadata. note: to see file changes made in a specific version, use `bit diff <component> <version> --parent`.
Flags: --json, --legacy, --remote, --browser, --compare

## bit snap [component-pattern]

create immutable component snapshots for development versions

creates snapshots with hash-based versions for development and testing. snapshots are immutable and exportable. by default snaps only new and modified components. use for development iterations before creating semantic version tags. snapshots maintain component history and enable collaboration without formal releases.
Flags: --message <message>, --unmodified, --unmerged, --build, --editor [editor], --skip-tests, --skip-tasks <string>, --skip-auto-snap, --disable-snap-pipeline, --ignore-build-errors, --loose, --rebuild-deps-graph, --ignore-issues <issues>, --fail-fast

## bit start [component-pattern]

launch the Bit development server

starts the local development server providing a UI to browse, preview, and interact with components. works in both workspaces and scopes. opens automatically in your browser at http://localhost:3000 (or specified port). includes hot module reloading for development.
Flags: --dev, --port [port-number], --rebuild, --skip-ui-build, --verbose, --no-browser, --show-internal-urls, --skip-compilation, --ui-root-name [type]

## bit stash <sub-command>

temporarily save and restore component changes

temporarily stores modified component files without creating versions. allows saving work-in-progress changes and switching context, then restoring changes later.
Flags: --pattern, --message <string>

## bit stash save

stash modified components
Flags: --pattern, --include-new, --message <string>

## bit stash load [stash-id]

apply the changes according to the stash. if no stash-id provided, it loads the latest stash
Flags: --auto-merge-resolve <merge-strategy>, --manual, --force-ours, --force-theirs

## bit stash list

list stash

## bit status

show workspace component status and issues

displays the current state of all workspace components including new, modified, staged, and problematic components. identifies blocking issues that prevent tagging/snapping and provides warnings with --warnings flag. essential for understanding workspace health before versioning components.
Flags: --json, --warnings, --verbose, --lanes, --strict, --fail-on-error, --ignore-circular-dependencies

## bit system <sub-command>

access system-level operations and debugging tools

provides commands for system-level operations including viewing and tailing debug logs. useful for troubleshooting issues and monitoring Bit's internal operations in real-time.

## bit system log

print debug.log to the screen

## bit system tail-log

print the log file to the screen as it is being written

similar to linux "tail -f" command

## bit tag [component-patterns...]

create immutable component snapshots with semantic version tags

creates tagged versions using semantic versioning (semver) for component releases. tags are immutable and exportable. by default tags all new and modified components. supports version specification per pattern using "@" (e.g. foo@1.0.0, bar@minor). use for official releases. for development versions, use 'bit snap' instead.
Flags: --message <message>, --unmodified, --editor [editor], --versions-file <path>, --ver <version>, --increment <level>, --prerelease-id <id>, --patch, --minor, --major, --pre-release [identifier], --snapped, --unmerged, --skip-tests, --skip-tasks <string>, --skip-auto-tag, --soft, --persist [skip-build], --disable-tag-pipeline, --ignore-build-errors, --rebuild-deps-graph, --increment-by <number>, --ignore-issues <issues>, --ignore-newest-version, --fail-fast, --build, --loose

## bit templates

list available templates for creating components and workspaces

Lists available templates. Inside a workspace it shows component templates for 'bit create'; outside a workspace it shows workspace templates for 'bit new'.
Flags: --show-all, --aspect <aspect-id>, --json

## bit test [component-pattern]

run component tests

executes tests using the testing framework configured by each component's environment (Jest, Mocha, etc.). by default only runs tests for new and modified components. use --unmodified to test all components. supports watch mode, coverage reporting, and debug mode for development workflows.
Flags: --watch, --debug, --unmodified, --junit <filepath>, --coverage, --env <id>, --update-snapshot, --json

## bit undeprecate <id>

remove the deprecation status from a component

reverses the deprecation of a component, removing warnings and allowing normal use again.

## bit uninstall [packages...]

remove dependencies from workspace

removes specified packages from workspace.jsonc dependency policy and runs install to update node_modules.

## bit unset-peer <component-id>

remove always-peer configuration from component

removes the always-peer marking from a component, allowing it to be installed as a regular dependency. reverses the effect of 'bit set-peer' command. the component will be treated normally in dependency resolution.

## bit update [package-patterns...]

update workspace dependencies to newer versions

updates dependencies in workspace.jsonc to newer versions and runs install to apply changes. by default, updates to highest semver-compatible versions. use --major, --minor, or --patch for specific version types. supports glob patterns to update specific packages. prompts for confirmation unless --yes is specified.
Flags: --yes, --patch, --minor, --major, --semver

## bit validate [component-pattern]

run type-checking, linting, and testing in sequence

validates components by running check-types, lint, and test commands in sequence. stops at the first failure and returns a non-zero exit code. by default validates only new and modified components. use --all to validate all components.
Flags: --all, --continue-on-error

## bit version

display the installed Bit version
Flags: --json

## bit watch

watch and compile components on file changes

monitors component files for changes and automatically recompiles them using their environment's configured compiler. enables immediate feedback during development by keeping components compiled as you work. by default uses file system events (not polling) to minimize CPU usage - enable polling with "bit config set watch_use_polling true" if needed.
Flags: --verbose, --skip-pre-compilation, --check-types [string], --skip-import, --generate-types, --trigger <comp-id>

## bit whoami

display the currently authenticated Bit Cloud user

shows the username of the currently logged in Bit Cloud account. verifies authentication status with the cloud service and displays the active username. useful for confirming authentication before publishing or when switching between accounts.

## bit why <dependency-name>

find components that use the specified dependency

searches workspace components to find which ones depend on the specified package or component. useful for understanding dependency usage before removing packages or when refactoring components. supports both exact version matching and package name patterns.
Flags: --depth <number>

## bit ws-config <sub-command>

generate IDE configuration files

writes configuration files (tsconfig.json, eslintrc.js, etc.) to your workspace for better IDE support. automatically generates configs based on your components' environments and settings. useful for enabling proper IntelliSense, linting, and type-checking in your IDE.

## bit ws-config write

write config files in the workspace. useful for IDEs
Flags: --clean, --writers <writers>, --silent, --no-dedupe, --dry-run, --dry-run-with-content, --verbose, --json

## bit ws-config clean

clean (delete) written config files in the workspace. useful for IDEs
Flags: --silent, --writers <writers>, --dry-run, --json

## bit ws-config list

list config writers
Flags: --json

---

Run `bit <command> --help` for more details.
