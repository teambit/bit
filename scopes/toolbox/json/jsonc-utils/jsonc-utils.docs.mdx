---
labels: ['typescript', 'utils', 'json', 'jsonc', 'formatting', 'comments', 'parser']
description: 'Utilities for parsing and stringifying JSONC files while preserving formatting and comments.'
---

import { Tabs, TabList, TabPanels, Tab, TabPanel } from '@teambit/design.ui.surfaces.tabs';

# JSONC Utils

Utilities for working with JSONC (JSON with Comments) files while preserving their original formatting, including:
- **Indentation style** (2 spaces, 4 spaces, tabs)
- **Newline characters** (LF, CRLF)
- **Comments**

This is particularly useful when you need to programmatically update configuration files without losing their human-readable formatting.

## Installation

```bash
bit install @teambit/toolbox.json.jsonc-utils
```

## Quick Start

The easiest way to update a JSONC file while preserving its formatting:

```ts
import { updateJsoncPreservingFormatting } from '@teambit/toolbox.json.jsonc-utils';

const originalContent = `{
  // This is a comment
  "name": "my-package",
  "version": "1.0.0"
}`;

const updatedContent = updateJsoncPreservingFormatting(originalContent, (data) => {
  data.version = "2.0.0";
  return data;
});

// Output preserves comments and formatting:
// {
//   // This is a comment
//   "name": "my-package",
//   "version": "2.0.0"
// }
```

## Use Cases

### Updating env.jsonc Files

When updating component environment configurations, preserve the original formatting:

```ts
import fs from 'fs-extra';
import { updateJsoncPreservingFormatting } from '@teambit/toolbox.json.jsonc-utils';

async function updateEnvDependency(
  envJsoncPath: string,
  pkgName: string,
  newVersion: string
) {
  const content = await fs.readFile(envJsoncPath, 'utf-8');
  
  const updated = updateJsoncPreservingFormatting(content, (envJsonc) => {
    const dep = envJsonc.policy?.runtime?.find((d) => d.name === pkgName);
    if (dep) {
      dep.version = newVersion;
    }
    return envJsonc;
  });
  
  await fs.writeFile(envJsoncPath, updated);
}
```

### Updating workspace.jsonc

Preserve team preferences for indentation when updating workspace config:

```ts
import { updateJsoncPreservingFormatting } from '@teambit/toolbox.json.jsonc-utils';

const updatedWorkspace = updateJsoncPreservingFormatting(
  workspaceContent,
  (config) => {
    config['teambit.workspace/workspace'].defaultScope = 'my-org.my-scope';
    return config;
  }
);
```

### Working with Different Indentation Styles

Handle files with different formatting preferences:

```ts
import { detectJsoncFormatting, stringifyJsonc } from '@teambit/toolbox.json.jsonc-utils';

// Detect existing formatting
const formatting = detectJsoncFormatting(originalContent);

// Modify data
const updatedData = { ...parsedData, version: '2.0.0' };

// Stringify with original formatting
const result = stringifyJsonc(updatedData, formatting);
```

## Real-World Example

This is exactly how Bit's `bit update` command preserves your env.jsonc formatting when updating dependencies:

```ts
async updateEnvJsoncPolicies(outdatedPkgs) {
  await pMapSeries(components, async (component) => {
    const envJsoncFile = component.filesystem.files.find(
      (file) => file.relative === 'env.jsonc'
    );
    if (!envJsoncFile) return;

    const envJsoncContent = envJsoncFile.contents.toString();
    const updatedContent = updateJsoncPreservingFormatting(
      envJsoncContent,
      (envJsonc) => {
        // Update dependency versions
        const dep = envJsonc.policy?.runtime?.find(
          (d) => d.name === pkg.name
        );
        if (dep) {
          dep.version = pkg.latestRange;
        }
        return envJsonc;
      }
    );

    await fs.writeFile(absPath, updatedContent);
  });
}
```

## Type Definitions

```ts
export type JsoncFormatting = {
  indent: string;
  newline: string;
};
```

## Why Preserve Formatting?

When working in teams, developers often have different preferences for code formatting:
- Some prefer 2 spaces, others 4 spaces or tabs
- Windows users might have CRLF line endings
- Comments provide important context

By preserving the original formatting, you avoid:
- ❌ Unnecessary git diffs
- ❌ Formatting debates in code reviews
- ❌ Lost comments and documentation
- ❌ Breaking team conventions

Instead, you get:
- ✅ Clean, minimal diffs showing only actual changes
- ✅ Preserved comments and documentation
- ✅ Respect for team and individual preferences
- ✅ Better collaboration