import type { CommandOptions, Command, CommandArg } from './command';
import type { GroupsType } from './command-groups';
import { capitalize, pick } from 'lodash';
import { getCommandId } from './get-command-id';

export type GenerateOpts = {
  metadata?: Record<string, string>;
};

type CommandObject = ReturnType<typeof oneCommandToObject> & { commands?: any };

export class GenerateCommandsDoc {
  constructor(
    private commands: Command[],
    private options: GenerateOpts,
    private groups: GroupsType = {}
  ) {}

  generate(): string {
    const commands = this.getAllPublicCommandsSorted();
    let output = `${this.getFrontmatter()}
# CLI Reference

Run the following to list all available Bit commands (alternatively, use the \`-h\` alias, instead of \`--help\`):

\`\`\`sh
bit --help
\`\`\`

Run the following to get help on a specific command:

\`\`\`sh
bit COMMAND --help
\`\`\`

Run the following to get help on a specific sub-command:

\`\`\`sh
bit COMMAND SUB_COMMAND --help
\`\`\`
`;
    output += commands.map((cmd) => this.generateCommand(cmd)).join('\n');

    return output;
  }

  generateJson() {
    return this.commandsToObjects();
  }

  /**
   * Generate command list in the style of `bit --help` but without chalk colors.
   * For use in Claude Code skills.
   */
  generateSkillCommands(): string {
    const grouped = this.groupCommandsByGroup();
    const sections = Object.keys(grouped)
      .map((groupName) => {
        const groupDescription = this.groups[groupName] || capitalize(groupName);
        const cmds = grouped[groupName];
        const commandLines = cmds
          .map((cmd) => {
            const paddedName = cmd.name.padEnd(30, ' ');
            let line = `    ${paddedName} - ${cmd.description || ''}`;
            if (cmd.commands && cmd.commands.length > 0) {
              const subNames = cmd.commands.filter((sub) => !sub.private).map((sub) => getCommandId(sub.name));
              if (subNames.length > 0) {
                line += `\n      Subcommands: ${subNames.join(', ')}`;
              }
            }
            return line;
          })
          .join('\n');
        return `  ${groupDescription}\n${commandLines}`;
      })
      .join('\n\n');

    return `---
name: bit-cli
description: "MUST consult before running ANY bit command. Do NOT guess bit commands from memory. This skill tells you the right command, correct syntax, subcommands, and flags."
---

# Bit CLI Quick Reference

<!-- This content is auto-generated by: bit cli generate --skill commands -->

usage: bit [--version] [--help] <command> [<args>]

bit documentation: https://bit.dev/

${sections}

For subcommands, arguments, and flags, see [CLI_REFERENCE.md](CLI_REFERENCE.md).
Run 'bit <command> --help' for more information on a specific command.`;
  }

  /**
   * Generate command reference with description, args, and flags.
   * For use in Claude Code skills.
   */
  generateSkillFlags(): string {
    const publicCommands = this.getAllPublicCommandsSorted();
    const sections: string[] = [];

    for (const cmd of publicCommands) {
      this.collectSkillCommandSections(cmd, '', sections);
    }

    return `# Bit CLI Command Reference

${sections.join('\n\n')}

---
Run \`bit <command> --help\` for more details.`;
  }

  private collectSkillCommandSections(cmd: Command, prefix: string, sections: string[]): void {
    const cmdId = prefix ? `${prefix} ${getCommandId(cmd.name)}` : getCommandId(cmd.name);
    const lines: string[] = [];

    // Command usage - use full cmd.name which may include args like "set <key> <val>"
    let usage = prefix ? `bit ${prefix} ${cmd.name}` : `bit ${cmd.name}`;
    // Only append arguments if they're not already in cmd.name
    if (cmd.arguments && cmd.arguments.length > 0 && !cmd.name.includes('<') && !cmd.name.includes('[')) {
      const args = cmd.arguments.map((arg) => (arg.name.includes('...') ? `[${arg.name}]` : `<${arg.name}>`)).join(' ');
      usage += ` ${args}`;
    }
    lines.push(`## ${usage}`);
    lines.push(''); // Blank line after heading for proper Markdown

    // Description with proper separation between description and extended description
    const description = (cmd.description || '').trim();
    const extended = cmd.extendedDescription ? cmd.extendedDescription.replace(/\n/g, ' ').trim() : '';
    if (description && extended) {
      lines.push(`${description}\n\n${extended}`);
    } else if (description || extended) {
      lines.push(description || extended);
    }

    // Flags (filtering out DEPRECATED and UNSUPPORTED)
    if (cmd.options && cmd.options.length > 0) {
      const flags = cmd.options
        .filter((opt) => {
          const desc = opt[2] || '';
          return !desc.startsWith('DEPRECATED') && !desc.startsWith('UNSUPPORTED');
        })
        .map((opt) => `--${opt[1]}`);

      if (flags.length > 0) {
        lines.push(`Flags: ${flags.join(', ')}`);
      }
    }

    sections.push(lines.join('\n'));

    // Process subcommands
    if (cmd.commands && cmd.commands.length > 0) {
      for (const subCmd of cmd.commands) {
        if (!subCmd.private) {
          this.collectSkillCommandSections(subCmd, cmdId, sections);
        }
      }
    }
  }

  private groupCommandsByGroup(): { [group: string]: Command[] } {
    const publicCommands = this.commands.filter((cmd) => !cmd.private && cmd.description);
    const grouped: { [group: string]: Command[] } = {};

    for (const cmd of publicCommands) {
      const group = cmd.group || 'ungrouped';
      if (!grouped[group]) {
        grouped[group] = [];
      }
      grouped[group].push(cmd);
    }

    return grouped;
  }

  private commandsToObjects(commands: Command[] = this.commands): CommandObject[] {
    return commands.map((command) => {
      const cmdObject: CommandObject = oneCommandToObject(command);
      if (command.commands?.length) {
        cmdObject.commands = this.commandsToObjects(command.commands);
      }
      return cmdObject;
    });
  }

  private getFrontmatter() {
    const metadata = this.options.metadata;
    if (!metadata) {
      return '';
    }
    const metadataStr = Object.keys(metadata)
      .map((key) => `${key}: ${metadata[key]}`)
      .join('\n');

    return `---
    ${metadataStr}
    ---
`;
  }

  private getAllPublicCommandsSorted() {
    const publicCommands = this.commands.filter((cmd) => !cmd.private);
    return publicCommands.sort((a, b) => a.name.localeCompare(b.name));
  }

  private generateCommand(cmd: Command) {
    const commandName = getCommandId(cmd.name);
    let result = `## ${commandName}  \n\n`;
    if (cmd.alias && cmd.alias.length > 0) {
      result += `**Alias**: \`${cmd.alias}\`  \n`;
    }
    result += `**Description**: ${this.formatDescription(cmd)}`;
    result += `\`bit ${cmd.name}\`  \n\n`;

    if (cmd.commands && cmd.commands.length > 0) {
      result += this.generateSubCommands(cmd.commands, cmd);
    }
    result += this.generateArguments(cmd.arguments);
    result += this.generateOptions(cmd.options);
    result += `---  \n`;

    return result;
  }

  private generateSubCommands(subCommands: Command[], command: Command) {
    let ret = '';
    subCommands.forEach((subCommand) => {
      const commandName = getCommandId(command.name);
      const subcommandName = getCommandId(subCommand.name);
      const usage = `${commandName} ${subCommand.name}`;
      ret += `### ${commandName} ${subcommandName} \n`;
      ret += `**Usage**: \`${usage}\`  \n\n`;
      ret += `**Description**: ${this.formatDescription(subCommand)}`;

      ret += '\n';
      ret += this.generateArguments(subCommand.arguments);
      ret += this.generateOptions(subCommand.options);
    });
    return ret;
  }

  private generateArguments(args?: CommandArg[]): string {
    if (!args || !args.length) return '';
    let output = `| **Arg** | **Description** |  \n`;
    output += `|---|:-----:|\n`;
    args.forEach((arg) => {
      const { name, description } = arg;
      output += `|\`${name}\`|${(description || '').replaceAll('\n', ' ')}|\n`;
    });
    output += `\n`;
    return output;
  }

  private generateOptions(options: CommandOptions): string {
    if (!options || options.length <= 0) return '';
    let output = `| **Option** | **Option alias** | **Description**|  \n`;
    output += `|---|:-----:|---|\n`;
    options.forEach((opt) => {
      const [alias, flag, description] = opt;
      const aliasFormatted = alias ? `\`-${alias}\`` : '   ';
      const flagFormatted = `--${flag}`;
      output += `|\`${flagFormatted}\`|${aliasFormatted}|${description.replaceAll('\n', ' ')}|\n`;
    });
    output += `\n`;
    return output;
  }

  private formatStringToMD(str: string): string {
    return str.split('\n').join('  \n');
  }

  private formatDescription(command: Command): string {
    const extendedDescription = command.extendedDescription
      ? `  \n${this.formatStringToMD(command.extendedDescription)}`
      : '';
    const description = this.formatStringToMD(command.description as string);
    return `${description}${extendedDescription}  \n\n`;
  }
}

function oneCommandToObject(command: Command) {
  return pick(command, [
    'name',
    'alias',
    'options',
    'description',
    'extendedDescription',
    'group',
    'private',
    'internal',
    'remoteOp',
    'skipWorkspace',
    'arguments',
    'examples',
  ]);
}
